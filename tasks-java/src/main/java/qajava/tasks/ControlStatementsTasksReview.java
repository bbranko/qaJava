package qajava.tasks;/*
Split into groups of 3 to 5.
Work on tasks individually.
Once everyone is done, exchange your work and compare solutions.

1. print out first n numbers of Fibonacci sequence, where n is for example 10
2. print out all prime numbers from 1 to n, where n is for example 100
3. foobarbazz:
   For a number range from 1 to n, where n is for example 100
   Write a program that:
   - printouts "foo" when number is divisible by 3
   - printouts "bar" when number is divisible by 5
   - printouts "bazz" when number is divisible by both 3 and 5

bonus:
1. implement switch statement logic via if statement
   - example program: map numbers from 1 to 7 to name of day of the week; for example if number is 1, output should be "Monday",
     but map 6 and 7 (Saturday and Sunday) to printout "It is weekend!".
2. implement for loop with while
   - example program: sum of integer numbers in range from i to j, where i<j
3. implement do_while loop with for
   - example program: printout random numbers generated by Math.rand() until value is bigger than 0.6

bonusbonus:
- implement each task as its own separate function
*/

import java.util.HashMap;
import java.util.Map;

public class ControlStatementsTasksReview {
  public static void main(String[] args) {
//    primeNumbers(0, 100000);
//    fuubarbazz(16);
//    doWhileWithFor();
    fibonacci(15);
  }



  static void primeNumbers(int start, int end) {

    StringBuilder answer = new StringBuilder();
    long timeStart = System.nanoTime();

    for (int i = start; i <= end; i++) {
      boolean isPrime = true;
      //tip, it is enough to go up to half of the number!
      //keep in mind that small improvements add up real fast depending on amount!
      for (int j = 2; j < i / 2; j++) {
//      for (int j = 2; j < i ; j++) {
        if (i % j == 0) {
          isPrime = false;
          break;
        }
      }

      if (isPrime) {
        answer.append(i).append('\n');
//        System.out.println(i);
      }
    }

    long timeEnd = System.nanoTime();
    System.out.println(answer);
    System.out.println("Time took: " + (timeEnd - timeStart) / 1000000);

  }

  static void fuubarbazz(int n) {
    String s;
    for (int i = 0; i < n; i++) {
      s = "";

      if (i % 3 == 0) {
        s += "fuu";
      }
      if (i % 5 == 0) {
        s += "bar";
      }
      if (i % 3 == 0 && i % 5 == 0) {
//      if (i % 15 == 0) {
        s += "bazz";
      }

      if (!s.isEmpty()) {
        System.out.println(s);
      }

    }

    //--
    System.out.println("--");
    //--

    for (int i = 0; i < n; i++) {
      s = "";

      if (i % 3 == 0) {
        s += "fuu";
      } else if (i % 5 == 0) {
        s += "bar";
      } else if (i % 3 == 0 && i % 5 == 0) {
        s += "bazz";
      }

      if (!s.isEmpty()) {
        System.out.println(s);
      }

    }
    //--
    System.out.println("--");
    //--

    for (int i = 0; i < n; i++) {
      s = "";

      //if order in chain si VERY important!!!
      if (i % 3 == 0 && i % 5 == 0) {
        s += "bazz";
      } else if (i % 3 == 0) {
        s += "fuu";
      } else if (i % 5 == 0) {
        s += "bar";
      }

      if (!s.isEmpty()) {
        System.out.println(s);
      }

    }
  }

  static void doWhileWithFor() {
    double randomValue = Math.random();
    System.out.println(randomValue);
    for (; randomValue < 0.6; ) {
      randomValue = Math.random();
      System.out.println(randomValue);
    }

    //--
    System.out.println("--");
    //--

    double randomValue2;
    do {
      randomValue2 = Math.random();
      System.out.println(randomValue2);
    } while (randomValue2 < 0.6);

  }


  //BONUS EXAMPLES (recursion, cache)
  static Map<Integer, Integer> fibonacciCache = new HashMap<>();

  static int fibonacciRecursiveWithCache(int counter) {
    if (counter <= 1) {
      return counter;
    }

    //cache can be ql, but be very careful with its size! Especially so, if it is a permanent cache!
    //permanent cache means that values contained in it never expire, thus memory for those values never gets garbage-collected
    Integer value = fibonacciCache.get(counter);
    if (value != null) {
      return value;
    }

    //recursion can be ql, but be very careful with depth of its callstack!
    value = fibonacciRecursiveWithCache(counter - 1) + fibonacciRecursiveWithCache(counter - 2);
    fibonacciCache.put(counter, value);
    return value;
  }

  static void fibonacci(int counter) {

    System.out.print("0");
    for (int i = 0, n1 = 0, n2 = 1, h; i <= counter; i++) {
      h = n1 + n2;
      n1 = n2;
      n2 = h;
      System.out.print(" " + n1);
    }

    //--
    System.out.println("\n--");
    //--

    for (int i = 0; i <= counter; i++) {
      System.out.print(fibonacciRecursiveWithCache(i) + " ");
    }
    System.out.println();
  }

}

